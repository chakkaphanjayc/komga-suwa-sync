// Komga-Suwayomi Sync Dashboard JavaScript
// @ts-nocheck

class SyncDashboard {
    constructor() {
        this.socket = null;
        this.currentTab = 'dashboard';
        this.logs = [];
        this.activityLog = [];
        this.komgaManga = []; // Store full Komga manga data
        this.suwayomiManga = []; // Store full Suwayomi manga data
        this.init();
    }

    init() {
        this.connectWebSocket();
        this.setupEventListeners();
        this.loadInitialData();
        this.startStatusUpdates();
    }

    connectWebSocket() {
        this.socket = io();

        this.socket.on('connect', () => {
            console.log('Connected to server');
            this.updateStatus('Connected', 'connected');
        });

        this.socket.on('disconnect', () => {
            console.log('Disconnected from server');
            this.updateStatus('Disconnected', 'error');
        });

        this.socket.on('log', (data) => {
            this.handleLog(data);
        });

        this.socket.on('sync-status', (data) => {
            this.updateSyncStatus(data);
        });

        this.socket.on('stats-update', (data) => {
            this.updateStats(data);
        });

        this.socket.on('activity', (data) => {
            this.addActivity(data);
        });
    }

    setupEventListeners() {
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tabId = e.target.onclick.toString().match(/'([^']+)'/)[1];
                this.showTab(tabId);
            });
        });

        // Configuration forms
        document.getElementById('komga-config').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveConfig('komga');
        });

        document.getElementById('suwa-config').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveConfig('suwa');
        });

        document.getElementById('sync-config').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveConfig('sync');
        });

        // Control buttons
        document.getElementById('start-sync').addEventListener('click', () => {
            this.sendCommand('start-sync');
        });

        document.getElementById('stop-sync').addEventListener('click', () => {
            this.sendCommand('stop-sync');
        });

        document.getElementById('run-match').addEventListener('click', () => {
            this.sendCommand('run-match');
        });

        document.getElementById('test-connections').addEventListener('click', () => {
            this.testConnections();
        });

        document.getElementById('test-connections-and-sync').addEventListener('click', () => {
            this.testConnectionsAndSync();
        });

        document.getElementById('refresh-matched').addEventListener('click', () => {
            this.loadMatchedManga();
        });

        // Logs controls
        document.getElementById('clear-logs').addEventListener('click', () => {
            this.clearLogs();
        });

        document.getElementById('download-logs').addEventListener('click', () => {
            this.downloadLogs();
        });

        document.getElementById('log-filter').addEventListener('change', (e) => {
            this.filterLogs(e.target.value);
        });

        // API Debug buttons
        document.getElementById('test-komga').addEventListener('click', () => {
            this.testAPI('komga');
        });

        document.getElementById('test-suwa').addEventListener('click', () => {
            this.testAPI('suwa');
        });

        document.getElementById('test-komga-series').addEventListener('click', () => {
            this.quickAPITest('komga-series');
        });

        document.getElementById('test-suwa-library').addEventListener('click', () => {
            this.quickAPITest('suwa-library');
        });

        document.getElementById('test-mapping-count').addEventListener('click', () => {
            this.quickAPITest('mapping-count');
        });

        // Only add GraphQL test listener if element exists
        const graphqlBtn = document.getElementById('test-graphql');
        if (graphqlBtn) {
            graphqlBtn.addEventListener('click', () => {
                this.testCustomGraphQL();
            });
        }

        // Mappings
        document.getElementById('refresh-mappings').addEventListener('click', () => {
            this.loadMappings();
        });

        // Manga lists - only add listeners if elements exist
        const komgaMangaBtn = document.getElementById('refresh-komga-manga');
        const suwayomiMangaBtn = document.getElementById('refresh-suwayomi-manga');
        const komgaSearch = document.getElementById('komga-search');
        const suwayomiSearch = document.getElementById('suwayomi-search');
        
        if (komgaMangaBtn) {
            komgaMangaBtn.addEventListener('click', () => {
                this.loadKomgaManga();
            });
        }
        if (suwayomiMangaBtn) {
            suwayomiMangaBtn.addEventListener('click', () => {
                this.loadSuwayomiManga();
            });
        }
        if (komgaSearch) {
            komgaSearch.addEventListener('input', (e) => {
                this.filterKomgaManga(e.target.value);
            });
        }
        if (suwayomiSearch) {
            suwayomiSearch.addEventListener('input', (e) => {
                this.filterSuwayomiManga(e.target.value);
            });
        }
    }

    showTab(tabId) {
        // Update tab buttons
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[onclick="showTab('${tabId}')"]`).classList.add('active');

        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        document.getElementById(tabId).classList.add('active');

        this.currentTab = tabId;

        // Load tab-specific data
        if (tabId === 'management') {
            this.loadConfig();
            this.checkAPIStatus();
        } else if (tabId === 'mappings') {
            this.loadMappings();
        } else if (tabId === 'manga-lists') {
            this.loadKomgaManga();
            this.loadSuwayomiManga();
        }
    }

    async loadInitialData() {
        try {
            const response = await fetch('/api/stats');
            const stats = await response.json();
            this.updateStats(stats);
        } catch (error) {
            console.error('Failed to load initial data:', error);
        }
    }

    startStatusUpdates() {
        setInterval(() => {
            this.checkAPIStatus();
        }, 30000); // Check every 30 seconds
    }

    updateStatus(message, type = 'info') {
        const statusText = document.querySelector('#sync-status .status-text');
        statusText.textContent = message;
        statusText.className = `status-text ${type}`;
    }

    updateSyncStatus(data) {
        const lastSyncText = document.querySelector('#last-sync .status-text');
        if (data.lastSync) {
            lastSyncText.textContent = new Date(data.lastSync).toLocaleString();
        }

        if (data.isRunning !== undefined) {
            this.updateStatus(data.isRunning ? 'Running' : 'Stopped', data.isRunning ? 'connected' : 'error');
        }
    }

    updateStats(stats) {
        document.getElementById('series-count').textContent = stats.seriesMappings || 0;
        document.getElementById('chapter-count').textContent = stats.chapterMappings || 0;
        document.getElementById('sync-cycles').textContent = stats.syncCycles || 0;
        document.getElementById('error-count').textContent = stats.errors || 0;
    }

    handleLog(data) {
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: data.level || 'info',
            message: data.message || data,
            ...data
        };

        this.logs.push(logEntry);
        this.displayLog(logEntry);
    }

    displayLog(logEntry) {
        const logsContainer = document.getElementById('logs-container');
        const logElement = document.createElement('div');
        logElement.className = `log-entry log-${logEntry.level}`;

        const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();
        logElement.textContent = `[${timestamp}] ${logEntry.level.toUpperCase()}: ${logEntry.message}`;

        logsContainer.appendChild(logElement);
        logsContainer.scrollTop = logsContainer.scrollHeight;
    }

    addActivity(data) {
        const activityItem = {
            timestamp: new Date().toISOString(),
            ...data
        };

        this.activityLog.unshift(activityItem);
        if (this.activityLog.length > 50) {
            this.activityLog.pop();
        }

        this.displayActivity();
    }

    displayActivity() {
        const activityContainer = document.getElementById('activity-log');
        activityContainer.innerHTML = '';

        this.activityLog.slice(0, 20).forEach(activity => {
            const item = document.createElement('div');
            item.className = 'activity-item';

            const timestamp = new Date(activity.timestamp).toLocaleString();
            item.innerHTML = `
                <div>${activity.message}</div>
                <div class="timestamp">${timestamp}</div>
            `;

            activityContainer.appendChild(item);
        });
    }

    async saveConfig(type) {
        const form = document.getElementById(`${type}-config`);
        const formData = new FormData(form);
        const config = {};

        for (let [key, value] of formData.entries()) {
            config[key] = value;
        }

        // Handle authentication method selection for Suwayomi
        if (type === 'suwa') {
            const activeTab = document.querySelector('.auth-tab.active');
            if (activeTab && activeTab.textContent.includes('Basic')) {
                // Clear token if basic auth is selected
                config['suwa-token'] = '';
            } else {
                // Clear basic auth if token is selected
                config['suwa-user'] = '';
                config['suwa-pass'] = '';
            }
        }

        try {
            const response = await fetch(`/api/config/${type}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(config)
            });

            if (response.ok) {
                this.showNotification('Configuration saved successfully', 'success');
            } else {
                throw new Error('Failed to save configuration');
            }
        } catch (error) {
            console.error('Save config error:', error);
            this.showNotification('Failed to save configuration', 'error');
        }
    }

    async loadConfig() {
        try {
            const response = await fetch('/api/config');
            const config = await response.json();

            // Populate form fields
            Object.keys(config).forEach(section => {
                Object.keys(config[section]).forEach(key => {
                    const element = document.getElementById(`${key}`);
                    if (element) {
                        if (element.type === 'checkbox') {
                            element.checked = config[section][key] === 'true';
                        } else {
                            element.value = config[section][key];
                        }
                    }
                });
            });

            // Set authentication method based on available credentials
            if (config.suwa && config.suwa.user && config.suwa.pass) {
                this.switchAuthMethod('basic');
            } else {
                this.switchAuthMethod('token');
            }
        } catch (error) {
            console.error('Load config error:', error);
        }
    }

    sendCommand(command) {
        this.socket.emit('command', { command });
        this.showNotification(`Command sent: ${command}`, 'info');
    }

    async testConnections() {
        this.showNotification('Testing connections...', 'info');

        try {
            const response = await fetch('/api/test-connections');
            const results = await response.json();

            let message = 'Connection test results:\n';
            message += `Komga: ${results.komga ? '✓ Connected' : '✗ Failed'}\n`;
            message += `Suwayomi: ${results.suwa ? '✓ Connected' : '✗ Failed'}`;

            this.showNotification(message, results.komga && results.suwa ? 'success' : 'error');
        } catch (error) {
            this.showNotification('Connection test failed', 'error');
        }
    }

    clearLogs() {
        this.logs = [];
        document.getElementById('logs-container').innerHTML = '';
    }

    downloadLogs() {
        const logText = this.logs.map(log =>
            `[${log.timestamp}] ${log.level.toUpperCase()}: ${log.message}`
        ).join('\n');

        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `sync-logs-${new Date().toISOString()}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }

    filterLogs(level) {
        const logsContainer = document.getElementById('logs-container');
        logsContainer.innerHTML = '';

        const filteredLogs = level === 'all' ?
            this.logs :
            this.logs.filter(log => {
                const levels = ['debug', 'info', 'warn', 'error'];
                return levels.indexOf(log.level) >= levels.indexOf(level);
            });

        filteredLogs.forEach(log => this.displayLog(log));
    }

    async checkAPIStatus() {
        try {
            const response = await fetch('/api/status');
            const status = await response.json();

            this.updateAPIStatus('komga', status.komga);
            this.updateAPIStatus('suwa', status.suwa);
        } catch (error) {
            console.error('Status check error:', error);
        }
    }

    updateAPIStatus(api, status) {
        const dot = document.getElementById(`${api}-dot`);
        const text = document.getElementById(`${api}-status-text`);
        const details = document.getElementById(`${api}-details`);

        if (status.connected) {
            dot.className = 'status-dot connected';
            text.textContent = 'Connected';
            details.textContent = JSON.stringify(status.details, null, 2);
        } else {
            dot.className = 'status-dot error';
            text.textContent = 'Disconnected';
            details.textContent = status.error || 'Connection failed';
        }
    }

    async testAPI(api) {
        const dot = document.getElementById(`${api}-dot`);
        const text = document.getElementById(`${api}-status-text`);

        dot.className = 'status-dot loading';
        text.textContent = 'Testing...';

        try {
            const response = await fetch(`/api/test-${api}`);
            const result = await response.json();

            if (result.success) {
                dot.className = 'status-dot connected';
                text.textContent = 'Connected';
                document.getElementById(`${api}-details`).textContent = JSON.stringify(result.data, null, 2);
            } else {
                throw new Error(result.error);
            }
        } catch (error) {
            dot.className = 'status-dot error';
            text.textContent = 'Failed';
            document.getElementById(`${api}-details`).textContent = error.message;
        }
    }

    async quickAPITest(testType) {
        const responseElement = document.getElementById('api-response');

        try {
            const response = await fetch(`/api/quick-test/${testType}`);
            const result = await response.json();

            responseElement.textContent = JSON.stringify(result, null, 2);
        } catch (error) {
            responseElement.textContent = `Error: ${error.message}`;
        }
    }

    async getSchemaInfo() {
        const responseElement = document.getElementById('api-response');

        try {
            const response = await fetch('/api/schema-info');
            const result = await response.json();

            responseElement.textContent = JSON.stringify(result, null, 2);
        } catch (error) {
            responseElement.textContent = `Error: ${error.message}`;
        }
    }

    async loadMappings() {
        try {
            const [seriesResponse, chapterResponse] = await Promise.all([
                fetch('/api/mappings/series'),
                fetch('/api/mappings/chapters')
            ]);

            const seriesMappings = await seriesResponse.json();
            const chapterMappings = await chapterResponse.json();

            this.displaySeriesMappings(seriesMappings);
            this.displayChapterMappings(chapterMappings);
        } catch (error) {
            console.error('Load mappings error:', error);
        }
    }

    displaySeriesMappings(mappings) {
        const tbody = document.getElementById('series-tbody');
        tbody.innerHTML = '';

        mappings.forEach(mapping => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${mapping.komgaSeriesId}</td>
                <td>${mapping.suwaMangaId}</td>
                <td>${mapping.titleNorm}</td>
                <td>
                    <button class="btn btn-small btn-danger" onclick="deleteMapping('series', '${mapping.id}')">
                        Delete
                    </button>
                </td>
            `;
            tbody.appendChild(row);
        });
    }

    displayChapterMappings(mappings) {
        const tbody = document.getElementById('chapter-tbody');
        tbody.innerHTML = '';

        mappings.forEach(mapping => {
            const row = document.createElement('tr');
            const lastSync = mapping.lastPushedKomga || mapping.lastPushedSuwa;
            const lastSyncFormatted = lastSync ? new Date(lastSync).toLocaleString() : 'Never';

            row.innerHTML = `
                <td>${mapping.komgaBookId}</td>
                <td>${mapping.suwaChapterId}</td>
                <td>${mapping.chapter}</td>
                <td>${lastSyncFormatted}</td>
            `;
            tbody.appendChild(row);
        });
    }

    switchAuthMethod(method) {
        // Update tab buttons
        document.querySelectorAll('.auth-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelector(`[onclick="switchAuthMethod('${method}')"]`).classList.add('active');

        // Update form fields
        document.getElementById('token-auth').style.display = method === 'token' ? 'block' : 'none';
        document.getElementById('basic-auth').style.display = method === 'basic' ? 'block' : 'none';
    }

    async testConnectionsAndSync() {
        this.showNotification('Testing connections and starting sync...', 'info');

        try {
            const response = await fetch('/api/test-connections-and-sync');
            const results = await response.json();

            if (results.success) {
                this.showNotification('Connections tested successfully and sync started!', 'success');
                // Refresh matched manga after successful connection
                this.loadMatchedManga();
            } else {
                let message = 'Connection test failed:\n';
                if (results.komga && !results.komga.success) {
                    message += `Komga: ${results.komga.error}\n`;
                }
                if (results.suwayomi && !results.suwayomi.success) {
                    message += `Suwayomi: ${results.suwayomi.error}`;
                }
                this.showNotification(message, 'error');
            }
        } catch (error) {
            this.showNotification('Connection test and sync failed', 'error');
        }
    }

    async loadMatchedManga() {
        try {
            const response = await fetch('/api/matched-manga');
            const data = await response.json();

            this.displayMatchedManga(data.matched);
            document.getElementById('matched-count').textContent = `${data.total} matched series`;
        } catch (error) {
            console.error('Load matched manga error:', error);
            this.showNotification('Failed to load matched manga', 'error');
        }
    }

    displayMatchedManga(matched) {
        const container = document.getElementById('matched-manga-list');
        container.innerHTML = '';

        if (matched.length === 0) {
            container.innerHTML = '<p>No matched manga found.</p>';
            return;
        }

        matched.forEach(match => {
            const item = document.createElement('div');
            item.className = 'matched-item';

            const komgaTitle = match.komga ? match.komga.metadata.title : 'Unknown';
            const suwaTitle = match.suwayomi ? match.suwayomi.title : 'Unknown';

            item.innerHTML = `
                <div class="matched-header">
                    <strong>${komgaTitle}</strong> ↔ <strong>${suwaTitle}</strong>
                </div>
                <div class="matched-details">
                    <div>Komga ID: ${match.mapping.komgaSeriesId}</div>
                    <div>Suwayomi ID: ${match.mapping.suwaMangaId}</div>
                    <div>Normalized: ${match.mapping.titleNorm}</div>
                    <div>Created: ${new Date(match.mapping.createdAt).toLocaleString()}</div>
                </div>
            `;

            container.appendChild(item);
        });
    }

    async loadKomgaManga() {
        try {
            this.showNotification('Loading Komga manga...', 'info');
            const response = await fetch('/api/manga/komga');
            const data = await response.json();

            // Store the full data
            this.komgaManga = data.manga || [];
            
            // Clear search input
            const searchInput = document.getElementById('komga-search');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Display all manga initially
            this.displayKomgaManga(this.komgaManga);
            document.getElementById('komga-count').textContent = `${this.komgaManga.length} series`;
            this.showNotification('Komga manga loaded successfully', 'success');
        } catch (error) {
            console.error('Load Komga manga error:', error);
            this.showNotification('Failed to load Komga manga', 'error');
        }
    }

    async loadSuwayomiManga() {
        try {
            this.showNotification('Loading Suwayomi manga...', 'info');
            const response = await fetch('/api/manga/suwayomi');
            const data = await response.json();

            // Store the full data
            this.suwayomiManga = data.manga || [];
            
            // Clear search input
            const searchInput = document.getElementById('suwayomi-search');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Display all manga initially
            this.displaySuwayomiManga(this.suwayomiManga);
            document.getElementById('suwayomi-count').textContent = `${this.suwayomiManga.length} manga`;
            this.showNotification('Suwayomi manga loaded successfully', 'success');
        } catch (error) {
            console.error('Load Suwayomi manga error:', error);
            this.showNotification('Failed to load Suwayomi manga', 'error');
        }
    }

    filterKomgaManga(searchTerm) {
        if (!searchTerm.trim()) {
            // If search is empty, show all manga
            this.displayKomgaManga(this.komgaManga);
            document.getElementById('komga-count').textContent = `${this.komgaManga.length} series`;
            return;
        }

        const searchLower = searchTerm.toLowerCase().trim();
        const searchWords = searchLower.split(/\s+/).filter(word => word.length > 0);

        const filtered = this.komgaManga.filter(series => {
            const title = (series.metadata ? series.metadata.title : series.name || '').toLowerCase();
            const author = (series.metadata && series.metadata.authors ? series.metadata.authors.join(' ') : '').toLowerCase();
            const seriesId = series.id.toString().toLowerCase();

            // Check if all search words are found in any of the fields
            return searchWords.every(word =>
                title.includes(word) ||
                author.includes(word) ||
                seriesId.includes(word) ||
                // Also check for partial matches and fuzzy matching
                this.fuzzyMatch(title, word) ||
                this.fuzzyMatch(author, word)
            );
        });

        this.displayKomgaManga(filtered);
        document.getElementById('komga-count').textContent = `${filtered.length} of ${this.komgaManga.length} series`;
    }

    filterSuwayomiManga(searchTerm) {
        if (!searchTerm.trim()) {
            // If search is empty, show all manga
            this.displaySuwayomiManga(this.suwayomiManga);
            document.getElementById('suwayomi-count').textContent = `${this.suwayomiManga.length} manga`;
            return;
        }

        const searchLower = searchTerm.toLowerCase().trim();
        const searchWords = searchLower.split(/\s+/).filter(word => word.length > 0);

        const filtered = this.suwayomiManga.filter(manga => {
            const title = (manga.title || '').toLowerCase();
            const author = (manga.author || '').toLowerCase();
            const mangaId = manga.id.toString().toLowerCase();

            // Check if all search words are found in any of the fields
            return searchWords.every(word =>
                title.includes(word) ||
                author.includes(word) ||
                mangaId.includes(word) ||
                // Also check for partial matches and fuzzy matching
                this.fuzzyMatch(title, word) ||
                this.fuzzyMatch(author, word)
            );
        });

        this.displaySuwayomiManga(filtered);
        document.getElementById('suwayomi-count').textContent = `${filtered.length} of ${this.suwayomiManga.length} manga`;
    }

    // Simple fuzzy matching function
    fuzzyMatch(text, pattern) {
        if (!text || !pattern) return false;

        // Remove special characters and normalize
        const normalizedText = text.replace(/[^\w\s]/g, '').toLowerCase();
        const normalizedPattern = pattern.replace(/[^\w\s]/g, '').toLowerCase();

        // Exact match
        if (normalizedText.includes(normalizedPattern)) return true;

        // Check if pattern is contained in text as consecutive characters
        let patternIndex = 0;
        for (let i = 0; i < normalizedText.length && patternIndex < normalizedPattern.length; i++) {
            if (normalizedText[i] === normalizedPattern[patternIndex]) {
                patternIndex++;
            }
        }
        return patternIndex === normalizedPattern.length;
    }

    displayKomgaManga(manga) {
        const container = document.getElementById('komga-manga-list');
        container.innerHTML = '';

        if (manga.length === 0) {
            if (this.komgaManga.length === 0) {
                container.innerHTML = '<p>No Komga series found.</p>';
            } else {
                container.innerHTML = '<p>No Komga series match your search.</p>';
            }
            return;
        }

        manga.forEach(series => {
            const item = document.createElement('div');
            item.className = 'manga-item clickable';
            item.dataset.seriesId = series.id;
            item.dataset.type = 'komga';

            const title = series.metadata ? series.metadata.title : series.name || 'Unknown Title';
            const author = series.metadata && series.metadata.authors ? series.metadata.authors.join(', ') : 'Unknown Author';
            const status = series.metadata ? series.metadata.status : 'Unknown';
            const booksCount = series.booksCount || 0;

            item.innerHTML = `
                <div class="manga-header">
                    <strong>${title}</strong>
                    <span class="click-hint">Click to view books</span>
                </div>
                <div class="manga-details">
                    <div>Author: ${author}</div>
                    <div>Status: ${status}</div>
                    <div>Books: ${booksCount}</div>
                    <div>ID: ${series.id}</div>
                </div>
            `;

            // Add click handler
            item.addEventListener('click', () => {
                this.showKomgaBooks(series.id, title);
            });

            container.appendChild(item);
        });
    }

    displaySuwayomiManga(manga) {
        const container = document.getElementById('suwayomi-manga-list');
        container.innerHTML = '';

        if (manga.length === 0) {
            if (this.suwayomiManga.length === 0) {
                container.innerHTML = '<p>No Suwayomi manga found.</p>';
            } else {
                container.innerHTML = '<p>No Suwayomi manga match your search.</p>';
            }
            return;
        }

        manga.forEach(mangaItem => {
            const item = document.createElement('div');
            item.className = 'manga-item clickable';
            item.dataset.mangaId = mangaItem.id;
            item.dataset.type = 'suwayomi';

            const title = mangaItem.title || 'Unknown Title';
            const author = mangaItem.author || 'Unknown Author';
            const status = mangaItem.status || 'Unknown';
            const chaptersCount = mangaItem.chapters ? mangaItem.chapters.length : 0;

            item.innerHTML = `
                <div class="manga-header">
                    <strong>${title}</strong>
                    <span class="click-hint">Click to view chapters</span>
                </div>
                <div class="manga-details">
                    <div>Author: ${author}</div>
                    <div>Status: ${status}</div>
                    <div>Chapters: ${chaptersCount}</div>
                    <div>ID: ${mangaItem.id}</div>
                </div>
            `;

            // Add click handler
            item.addEventListener('click', () => {
                this.showSuwayomiChapters(mangaItem.id, title);
            });

            container.appendChild(item);
        });
    }

    async showKomgaBooks(seriesId, seriesTitle) {
        try {
            this.showNotification(`Loading books for ${seriesTitle}...`, 'info');

            // Fetch books for this series
            const response = await fetch(`/api/komga/series/${seriesId}/books`);
            if (!response.ok) {
                throw new Error(`Failed to fetch books: ${response.status}`);
            }

            const books = await response.json();
            this.displayBooksModal(seriesTitle, books, 'komga');
        } catch (error) {
            console.error('Error fetching Komga books:', error);
            this.showNotification('Failed to load books', 'error');
        }
    }

    async showSuwayomiChapters(mangaId, mangaTitle) {
        try {
            this.showNotification(`Loading chapters for ${mangaTitle}...`, 'info');

            // Fetch chapters for this manga
            const response = await fetch(`/api/suwayomi/manga/${mangaId}/chapters`);
            if (!response.ok) {
                throw new Error(`Failed to fetch chapters: ${response.status}`);
            }

            const chapters = await response.json();
            this.displayChaptersModal(mangaTitle, chapters, 'suwayomi');
        } catch (error) {
            console.error('Error fetching Suwayomi chapters:', error);
            this.showNotification('Failed to load chapters', 'error');
        }
    }

    displayBooksModal(seriesTitle, books, type) {
        // Create modal container
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3>${seriesTitle} - Books</h3>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="books-list" id="books-list"></div>
                </div>
            </div>
        `;

        // Add to DOM
        document.body.appendChild(modal);

        // Populate books list
        const booksList = modal.querySelector('#books-list');
        if (books && books.length > 0) {
            books.forEach(book => {
                const bookItem = document.createElement('div');
                bookItem.className = 'book-item';

                const title = book.metadata ? book.metadata.title : book.name || 'Unknown Book';
                const number = book.metadata ? book.metadata.number : book.number || 'N/A';

                bookItem.innerHTML = `
                    <div class="book-header">
                        <strong>Book ${number}: ${title}</strong>
                    </div>
                    <div class="book-details">
                        <div>Pages: ${book.pagesCount || 0}</div>
                        <div>Size: ${this.formatBytes(book.sizeBytes || 0)}</div>
                        <div>ID: ${book.id}</div>
                    </div>
                `;

                booksList.appendChild(bookItem);
            });
        } else {
            booksList.innerHTML = '<p>No books found for this series.</p>';
        }

        // Add close functionality
        const closeBtn = modal.querySelector('.modal-close');
        closeBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }

    displayChaptersModal(mangaTitle, chapters, type) {
        // Create modal container
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h3>${mangaTitle} - Chapters</h3>
                    <button class="modal-close">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="chapters-list" id="chapters-list"></div>
                </div>
            </div>
        `;

        // Add to DOM
        document.body.appendChild(modal);

        // Populate chapters list
        const chaptersList = modal.querySelector('#chapters-list');
        if (chapters && chapters.length > 0) {
            chapters.forEach(chapter => {
                const chapterItem = document.createElement('div');
                chapterItem.className = 'chapter-item';

                const title = chapter.name || chapter.title || `Chapter ${chapter.chapterNumber || chapter.number || 'N/A'}`;
                const number = chapter.chapterNumber || chapter.number || 'N/A';

                chapterItem.innerHTML = `
                    <div class="chapter-header">
                        <strong>Chapter ${number}: ${title}</strong>
                    </div>
                    <div class="chapter-details">
                        <div>Pages: ${chapter.pagesCount || chapter.pageCount || 0}</div>
                        <div>Scanlator: ${chapter.scanlator || 'Unknown'}</div>
                        <div>ID: ${chapter.id}</div>
                    </div>
                `;

                chaptersList.appendChild(chapterItem);
            });
        } else {
            chaptersList.innerHTML = '<p>No chapters found for this manga.</p>';
        }

        // Add close functionality
        const closeBtn = modal.querySelector('.modal-close');
        closeBtn.addEventListener('click', () => {
            document.body.removeChild(modal);
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                document.body.removeChild(modal);
            }
        });
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    showNotification(message, type = 'info') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;

        // Style the notification
        Object.assign(notification.style, {
            position: 'fixed',
            top: '20px',
            right: '20px',
            padding: '15px 20px',
            borderRadius: '8px',
            color: 'white',
            fontWeight: '500',
            zIndex: '10000',
            boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
            maxWidth: '300px',
            wordWrap: 'break-word',
            opacity: '0',
            transform: 'translateY(-20px)',
            transition: 'all 0.3s ease'
        });

        // Set background color based on type
        const colors = {
            success: '#2ed573',
            error: '#ff4757',
            info: '#3742fa',
            warning: '#ffa502'
        };
        notification.style.backgroundColor = colors[type] || colors.info;

        // Add to DOM
        document.body.appendChild(notification);

        // Animate in
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.transform = 'translateY(0)';
        }, 10);

        // Remove after 4 seconds
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 4000);
    }
}

// Global function for tab switching (used in HTML onclick)
function showTab(tabId) {
    if (window.dashboard && typeof window.dashboard.showTab === 'function') {
        window.dashboard.showTab(tabId);
    } else {
        // If dashboard is not ready, wait a bit and try again
        setTimeout(() => {
            if (window.dashboard && typeof window.dashboard.showTab === 'function') {
                window.dashboard.showTab(tabId);
            }
        }, 100);
    }
}

// Global function for authentication method switching
function switchAuthMethod(method) {
    if (window.dashboard && typeof window.dashboard.switchAuthMethod === 'function') {
        window.dashboard.switchAuthMethod(method);
    }
}

// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.dashboard = new SyncDashboard();
});
